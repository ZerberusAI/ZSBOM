import sqlite3
import os
import json
from datetime import datetime, timedelta
import logging
from typing import Optional, Any, Dict

class VulnerabilityCache:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.logger = logging.getLogger(__name__)
        self._init_db()

    def _init_db(self):
        """Initialize SQLite database with required tables"""
        try:
            os.makedirs(os.path.dirname(self.db_path), exist_ok=True)

            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                CREATE TABLE IF NOT EXISTS vulnerability_data (
                    source TEXT PRIMARY KEY,
                    data TEXT,
                    last_updated TIMESTAMP
                )
                """)
                
                conn.execute("""
                CREATE TABLE IF NOT EXISTS scan_results (
                    scan_id TEXT PRIMARY KEY,
                    timestamp TIMESTAMP,
                    results TEXT
                )
                """)
                
                # Table for caching pip-compile results
                conn.execute("""
                CREATE TABLE IF NOT EXISTS pip_compile_cache (
                    cache_key TEXT PRIMARY KEY,
                    requirements_hash TEXT,
                    resolved_output TEXT,
                    timestamp TIMESTAMP
                )
                """)
        except Exception as e:
            self.logger.error(f"Failed to initialize cache database: {e}")
            raise

    def get_cached_data(self, source: str, ttl_hours: int) -> Optional[Dict]:
        """Retrieve cached data if not expired"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute(
                    "SELECT data, last_updated FROM vulnerability_data WHERE source = ?",
                    (source,)
                )
                result = cursor.fetchone()
                
                if result:
                    data, timestamp = result
                    cache_time = datetime.fromisoformat(timestamp)
                    if datetime.now() - cache_time < timedelta(hours=ttl_hours):
                        return json.loads(data)
                return None
        except Exception as e:
            self.logger.error(f"Failed to retrieve cached data: {e}")
            return None

    def cache_data(self, source: str, data: Any) -> bool:
        """Store data in cache"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute(
                    """
                    INSERT OR REPLACE INTO vulnerability_data (source, data, last_updated)
                    VALUES (?, ?, ?)
                    """,
                    (source, json.dumps(data), datetime.now().isoformat())
                )
                return True
        except Exception as e:
            self.logger.error(f"Failed to cache data: {e}")
            return False

    def store_scan_result(self, results: Dict) -> str:
        """Store scan results with timestamp"""
        scan_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute(
                    "INSERT INTO scan_results (scan_id, timestamp, results) VALUES (?, ?, ?)",
                    (scan_id, datetime.now().isoformat(), json.dumps(results))
                )
                return scan_id
        except Exception as e:
            self.logger.error(f"Failed to store scan results: {e}")
            return ""

    def get_cached_pip_compile(self, cache_key: str, ttl_hours: int) -> Optional[str]:
        """Retrieve cached pip-compile results if not expired"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute(
                    "SELECT resolved_output, timestamp FROM pip_compile_cache WHERE cache_key = ?",
                    (cache_key,)
                )
                result = cursor.fetchone()
                
                if result:
                    output, timestamp = result
                    cache_time = datetime.fromisoformat(timestamp)
                    if datetime.now() - cache_time < timedelta(hours=ttl_hours):
                        return output
                return None
        except Exception as e:
            self.logger.error(f"Failed to retrieve cached pip-compile results: {e}")
            return None

    def cache_pip_compile_result(self, cache_key: str, requirements_hash: str, resolved_output: str) -> bool:
        """Store pip-compile results in cache"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute(
                    """
                    INSERT OR REPLACE INTO pip_compile_cache 
                    (cache_key, requirements_hash, resolved_output, timestamp)
                    VALUES (?, ?, ?, ?)
                    """,
                    (cache_key, requirements_hash, resolved_output, datetime.now().isoformat())
                )
                return True
        except Exception as e:
            self.logger.error(f"Failed to cache pip-compile results: {e}")
            return False