import logging
from typing import Any, Dict, List, Optional, Tuple
from cvss import CVSS2, CVSS3, CVSS4

import requests

from .base import VulnerabilitySource


class OSVSource(VulnerabilitySource):
    def __init__(self, config, installed_packages: Dict[str, str], cache):
        self.installed_packages = installed_packages
        self.cache = cache
        self.ttl_hours = config['caching']['ttl_hours']
        self.logger = logging.getLogger(__name__)
        self.api_url = config['sources']['cve']['osv_dev']['url']

    def build_osv_query(self) -> Dict[str, Any]:
        return {
            "queries": [
                {
                    "package": {
                        "name": name,
                        "ecosystem": "PyPI"
                    },
                    "version": version
                }
                for name, version in self.installed_packages.items()
            ]
        }

    def fetch_vulnerabilities(self) -> List[Dict]:
        data = {}
        cache_key = "osv-python-vulns"

        if self.cache:
            cached_data = self.cache.get_cached_data(cache_key, self.ttl_hours)

            if cached_data:
                self.logger.info("✅ Using cached OSV data")
                data = cached_data

        if not data:
            self.logger.info("🔍 Fetching OSV data")
            payload = self.build_osv_query()
            response = requests.post(self.api_url, json=payload, timeout=20)
            response.raise_for_status()
            data = response.json().get("results", [])
            if self.cache:
                self.cache.cache_data(cache_key, data)

        return self.normalize_data(data)
    
    def normalize_data(self, data: list[dict]):
        normalized = []

        for item in data:
            if not item.get("vulns"):
                continue

            for vuln_data in item["vulns"]:
                vuln = self.get_vulns_details(vuln_data['id'])
                if not vuln:
                    #TODO: Add unknown status to this package
                    continue
                affected_pkg = vuln.get("affected", [{}])[0].get("package", {}).get("name", "").lower()
                installed_version = self.installed_packages.get(affected_pkg)
                score, severity = self.get_osv_severity(vuln)

                normalized.append({
                    "package_name": affected_pkg,
                    "installed_version": installed_version,
                    "vuln_id": vuln.get("id"),
                    "summary": vuln.get("summary"),
                    "severity": severity,
                    "cwes": self._extract_cwes(vuln),
                    "score": score,
                    "cvss_vector": self._get_cvss_vector(vuln),
                    "fix_version": self._extract_fix_version(vuln),
                    "aliases": vuln.get("aliases", []),
                    "affected_versions": vuln.get("affected"),
                    "references": [r["url"] for r in vuln.get("references", []) if "url" in r],
                    "reference_types": {r["url"]: r.get("type", "WEB") for r in vuln.get("references", []) if "url" in r},
                    "affected_ranges": self._extract_affected_ranges(vuln),
                })

        return normalized
    
    def get_vulns_details(self, id: str):
        try:
            detail_resp = requests.get(f"https://api.osv.dev/v1/vulns/{id}", timeout=15)
            detail_resp.raise_for_status()
            return detail_resp.json()
        except Exception as e:
            self.logger.warning(f"Failed to fetch OSV detail for {id}: {e}")

    def get_osv_severity(self, vuln: Dict) -> Tuple[Optional[float], str]:
        """
        Extract CVSS score & mapped severity from an OSV vulnerability.
        
        Returns:
            (score, severity_bucket)
            - score: float or None
            - severity_bucket: "CRITICAL", "HIGH", "MEDIUM", "LOW", "NONE", or "UNKNOWN"
        """
        severities = vuln.get("severity", [])
        for s in severities:
            cvss_type = s.get("type")
            vector = s.get("score")

            if not vector:
                continue

            try:
                if cvss_type == "CVSS_V2":
                    cvss = CVSS2(vector)
                    score = float(cvss.scores()[0])  # base score
                elif cvss_type == "CVSS_V3":
                    cvss = CVSS3(vector)
                    score = float(cvss.scores()[0])  # base score
                elif cvss_type == "CVSS_V4":
                    cvss = CVSS4(vector)
                    score = float(cvss.scores()[0])  # base score
                else:
                    continue

                return score, self._map_severity(score)
            except Exception as e:
                print(f"Error parsing CVSS vector {vector}: {e}")
                continue

        return None, "UNKNOWN"

    def _map_severity(self, score: float) -> str:
        if score is None:
            return "UNKNOWN"
        if score == 0.0:
            return "NONE"
        elif score <= 3.9:
            return "LOW"
        elif score <= 6.9:
            return "MEDIUM"
        elif score <= 8.9:
            return "HIGH"
        else:
            return "CRITICAL"


    def _extract_cwes(self, vuln: Dict) -> List[str]:
        if vuln.get("database_specific", {}):
            return vuln['database_specific'].get('cwe_ids', [])
        return []

    def _get_cvss_vector(self, vuln: Dict) -> str:
        """Extract CVSS vector string from vulnerability data"""
        severities = vuln.get("severity", [])
        for s in severities:
            if s.get("type") == "CVSS_V3":
                return s.get("score", "")
        return ""

    def _extract_fix_version(self, vuln: Dict) -> str:
        """Extract fix version from OSV affected ranges"""
        affected = vuln.get("affected", [])
        for affected_item in affected:
            ranges = affected_item.get("ranges", [])
            for range_item in ranges:
                # Prioritize ECOSYSTEM ranges for version-based fixes
                if range_item.get("type") == "ECOSYSTEM":
                    events = range_item.get("events", [])
                    for event in events:
                        if "fixed" in event:
                            return event["fixed"]
        return ""

    def _extract_affected_ranges(self, vuln: Dict) -> List[Dict]:
        """Extract detailed affected version ranges from OSV data"""
        affected_ranges = []
        affected = vuln.get("affected", [])
        
        for affected_item in affected:
            package_name = affected_item.get("package", {}).get("name", "")
            ranges = affected_item.get("ranges", [])
            
            for range_item in ranges:
                range_data = {
                    "type": range_item.get("type", ""),
                    "package": package_name,
                    "events": range_item.get("events", [])
                }
                if range_item.get("repo"):
                    range_data["repo"] = range_item["repo"]
                affected_ranges.append(range_data)
        
        return affected_ranges

